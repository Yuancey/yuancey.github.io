
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>22、class的基本语法 | 驿站</title>
    <meta name="author" content="Yuancey" />
    <meta name="description" content="写自己的故事" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>






<script src="https://cdn.staticfile.org/waline/2.15.8/waline.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline.min.css" />
<link rel="stylesheet" href="https://cdn.staticfile.org/waline/2.15.8/waline-meta.min.css" />




<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>驿站</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;驿站</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>22、class的基本语法</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/1/30
        </span>
        
        <span class="category">
            <a href="/categories/%E5%89%8D%E7%AB%AF/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                前端
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/ES6/" style="color: #ff7d73">ES6</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        
  <div id="toc">
      <strong class="sidebar-title">目录</strong>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-text">1、类的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81constructor-%E6%96%B9%E6%B3%95"><span class="toc-text">2、constructor() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">3、类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95"><span class="toc-text">4、实例属性的新写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88getter%EF%BC%89%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88setter%EF%BC%89"><span class="toc-text">5、取值函数（getter）和存值函数（setter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">6、属性表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Class-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">7、Class 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">8、静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-text">9、静态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-text">10、私有方法和私有属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1%E3%80%81%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">10.1、私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2%E3%80%81%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-text">10.2、私有属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3%E3%80%81%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">10.3、私有属性的写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-In%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">10.4 In运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E9%9D%99%E6%80%81%E5%9D%97"><span class="toc-text">11、静态块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">12、类的注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">12.1 严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">12.2 变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-name%E5%B1%9E%E6%80%A7"><span class="toc-text">12.3 name属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-Generator%E6%96%B9%E6%B3%95"><span class="toc-text">12.4 Generator方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-text">12.5 this的指向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81new-target-%E5%B1%9E%E6%80%A7"><span class="toc-text">13、new.target 属性</span></a></li></ol>
  </div>


        <p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class">class的基本语法</a></p>
<span id="more"></span>


<blockquote>
<p>1、类的由来<br>2、constructor() 方法<br>3、类的实例<br>4、实例属性的新写法<br>5、取值函数（getter）和存值函数（setter）<br>6、属性表达式<br>7、Class 表达式<br>8、静态方法<br>9、静态属性<br>10、私有方法和私有属性<br>11、静态块<br>12、类的注意点<br>13、new.target 属性</p>
</blockquote>
<h3 id="1、类的由来"><a href="#1、类的由来" class="headerlink" title="1、类的由来"></a>1、类的由来</h3><p><strong>类的数据类型就是函数，类本身就指向构造函数。</strong></p>
<pre><code class="js">class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true
</code></pre>
<p><strong>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</strong></p>
<pre><code class="js">class Point &#123;
  constructor() &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;

  toValue() &#123;
    // ...
  &#125;
&#125;

// 等同于

Point.prototype = &#123;
  constructor() &#123;&#125;,
  toString() &#123;&#125;,
  toValue() &#123;&#125;,
&#125;;
</code></pre>
<p><strong>在类的实例上面调用方法，其实就是调用原型上的方法。</strong></p>
<pre><code class="js">class B &#123;&#125;
const b = new B();

b.constructor === B.prototype.constructor // true
</code></pre>
<p><strong>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。</strong></p>
<pre><code class="js">class Point &#123;
  constructor()&#123;
    // ...
  &#125;
&#125;

Object.assign(Point.prototype, &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;);
</code></pre>
<p><strong>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</strong></p>
<h3 id="2、constructor-方法"><a href="#2、constructor-方法" class="headerlink" title="2、constructor() 方法"></a>2、constructor() 方法</h3><p>构造函数是类的初始方法，类的实例化时会自动调用。<br>constructor() 方法是类的构造方法，它会在实例化对象时自动调用。<code>构造函数的作用是初始类的实例。</code></p>
<p><strong>一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</strong></p>
<p><strong>类必须使用new调用，否则会报错</strong></p>
<pre><code class="js">class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</code></pre>
<h3 id="3、类的实例"><a href="#3、类的实例" class="headerlink" title="3、类的实例"></a>3、类的实例</h3><p><strong>生成类的实例的写法,使用new命令。</strong></p>
<p><strong>类的属性和方法，除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。（只有定义在this对象上的，是显示定义）</strong></p>
<p><strong>类的所有实例共享一个原型对象。</strong><br>这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
<h3 id="4、实例属性的新写法"><a href="#4、实例属性的新写法" class="headerlink" title="4、实例属性的新写法"></a>4、实例属性的新写法</h3><p><strong>实例属性现在除了可以定义在constructor()方法里面的this上面，也可以定义在类内部的最顶层。</strong><br>注意：新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型上面。</p>
<pre><code class="js">class IncreasingCounter &#123;
  _count = 0;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this._count;
  &#125;
  increment() &#123;
    this._count++;
  &#125;
&#125;
</code></pre>
<h3 id="5、取值函数（getter）和存值函数（setter）"><a href="#5、取值函数（getter）和存值函数（setter）" class="headerlink" title="5、取值函数（getter）和存值函数（setter）"></a>5、取值函数（getter）和存值函数（setter）</h3><p><strong>在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</strong></p>
<p><strong>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</strong></p>
<pre><code class="js">class CustomHTMLElement &#123;
  constructor(element) &#123;
    this.element = element;
  &#125;

  get html() &#123;
    return this.element.innerHTML;
  &#125;

  set html(value) &#123;
    this.element.innerHTML = value;
  &#125;
&#125;

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, &quot;html&quot;
);

&quot;get&quot; in descriptor  // true
&quot;set&quot; in descriptor  // true
</code></pre>
<h3 id="6、属性表达式"><a href="#6、属性表达式" class="headerlink" title="6、属性表达式"></a>6、属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<pre><code class="js">class CustomHTMLElement &#123;
  constructor(element) &#123;
    this.element = element;
  &#125;

  get html() &#123;
    return this.element.innerHTML;
  &#125;

  set html(value) &#123;
    this.element.innerHTML = value;
  &#125;
&#125;

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, &quot;html&quot;
);

&quot;get&quot; in descriptor  // true
&quot;set&quot; in descriptor  // true
</code></pre>
<h3 id="7、Class-表达式"><a href="#7、Class-表达式" class="headerlink" title="7、Class 表达式"></a>7、Class 表达式</h3><h3 id="8、静态方法"><a href="#8、静态方法" class="headerlink" title="8、静态方法"></a>8、静态方法</h3><p>类相当于实例的原型。所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，<br>而是直接通过类来调用，这就称为“静态方法”。</p>
<p><strong>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</strong></p>
<pre><code class="js">class Foo &#123;
  static bar() &#123;
    this.baz();
  &#125;
  static baz() &#123;
    console.log(&#39;hello&#39;);
  &#125;
  baz() &#123;
    console.log(&#39;world&#39;);
  &#125;
  //静态方法可以与非静态方法重名。
&#125;

Foo.bar() // hello
</code></pre>
<p><strong>父类的静态方法，可以被子类继承。</strong></p>
<pre><code class="js">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
&#125;

Bar.classMethod() // &#39;hello&#39;
</code></pre>
<p><strong>静态方法也是可以从super对象上调用的。</strong></p>
<pre><code class="js">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
  static classMethod() &#123;
    return super.classMethod() + &#39;, too&#39;;
  &#125;
&#125;

Bar.classMethod() // &quot;hello, too&quot;
</code></pre>
<h3 id="9、静态属性"><a href="#9、静态属性" class="headerlink" title="9、静态属性"></a>9、静态属性</h3><p>静态属性指的是Class本身的属性，即<code>Class.propName</code>,而不是定义在实例对象<code>this</code>上的属性。</p>
<pre><code class="js">// 老写法
class Foo &#123;
  // ...
&#125;
Foo.prop = 1;

// 新写法
class Foo &#123;
  static prop = 1;
&#125;
</code></pre>
<h3 id="10、私有方法和私有属性"><a href="#10、私有方法和私有属性" class="headerlink" title="10、私有方法和私有属性"></a>10、私有方法和私有属性</h3><h4 id="10-1、私有方法"><a href="#10-1、私有方法" class="headerlink" title="10.1、私有方法"></a>10.1、私有方法</h4><h4 id="10-2、私有属性"><a href="#10-2、私有属性" class="headerlink" title="10.2、私有属性"></a>10.2、私有属性</h4><p><strong>在属性名之前使用#表示。</strong><br><strong>不管在类的内部或外部，读取一个不存在的私有属性，也都会报错。读取一个不存在的公开属性会返回undefined。</strong></p>
<h4 id="10-3、私有属性的写法"><a href="#10-3、私有属性的写法" class="headerlink" title="10.3、私有属性的写法"></a>10.3、私有属性的写法</h4><pre><code class="js">class Foo &#123;
  #a;
  #b;
  constructor(a, b) &#123;
    this.#a = a;
    this.#b = b;
  &#125;
  #sum() &#123;
    return this.#a + this.#b;
  &#125;
  printSum() &#123;
    console.log(this.#sum());
  &#125;
&#125;
</code></pre>
<h4 id="10-4-In运算符"><a href="#10-4-In运算符" class="headerlink" title="10.4 In运算符"></a>10.4 In运算符</h4><p>in运算符对于Object.create()、Object.setPrototypeOf形成的继承，是无效的，因为这种继承不会传递私有属性。</p>
<h3 id="11、静态块"><a href="#11、静态块" class="headerlink" title="11、静态块"></a>11、静态块</h3><p>允许在类的内部设置一个代码块，在类生成时运行且只运行一次，主要作用是对静态属性进行初始化。以后，新建类的实例时，这个块就不运行了。<br>每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性。另外，静态块的内部不能有return语句。<br>静态块内部可以使用类名或this，指代当前类。<br>态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</p>
<pre><code class="js">class C &#123;
  static x = ...;
  static y;
  static z;

  static &#123;
    try &#123;
      const obj = doSomethingWith(this.x);
      this.y = obj.y;
      this.z = obj.z;
    &#125;
    catch &#123;
      this.y = ...;
      this.z = ...;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="12、类的注意点"><a href="#12、类的注意点" class="headerlink" title="12、类的注意点"></a>12、类的注意点</h3><h4 id="12-1-严格模式"><a href="#12-1-严格模式" class="headerlink" title="12.1 严格模式"></a>12.1 严格模式</h4><p>类和模块的内部，默认就是严格模式。</p>
<h4 id="12-2-变量提升"><a href="#12-2-变量提升" class="headerlink" title="12.2 变量提升"></a>12.2 变量提升</h4><p>类不存在变量提升</p>
<h4 id="12-3-name属性"><a href="#12-3-name属性" class="headerlink" title="12.3 name属性"></a>12.3 name属性</h4><p>本质上, es6的类只是es5构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<pre><code class="js">class Point &#123;&#125;
Point.name // &quot;Point&quot;
</code></pre>
<p>name属性总是返回紧跟在class关键字后面的类名。</p>
<h4 id="12-4-Generator方法"><a href="#12-4-Generator方法" class="headerlink" title="12.4 Generator方法"></a>12.4 Generator方法</h4><p>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。（会返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。）</p>
<h4 id="12-5-this的指向"><a href="#12-5-this的指向" class="headerlink" title="12.5 this的指向"></a>12.5 this的指向</h4><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<pre><code class="js">class Obj &#123;
  constructor() &#123;
    this.getThis = () =&gt; this;
  &#125;
&#125;

const myObj = new Obj();
myObj.getThis() === myObj // true
</code></pre>
<p>箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。</p>
<h3 id="13、new-target-属性"><a href="#13、new-target-属性" class="headerlink" title="13、new.target 属性"></a>13、new.target 属性</h3><p>ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。<br><strong>需要注意的是，子类继承父类时，new.target会返回子类。</strong></p>

    </div>
    
    
    
    
    
    <div id="comment">
        <div id="waline-container"></div>
    </div>
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 驿站
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yuancey
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    


<script>
    Waline.init({
        el: "#waline-container",
        serverURL: "",
        commentCount: false,
        pageview: false,
        emoji: "https://unpkg.com/@waline/emojis@1.2.0/weibo,https://unpkg.com/@waline/emojis@1.2.0/alus,https://unpkg.com/@waline/emojis@1.2.0/bilibili,https://unpkg.com/@waline/emojis@1.2.0/qq,https://unpkg.com/@waline/emojis@1.2.0/tieba,https://unpkg.com/@waline/emojis@1.2.0/tw-emoji".split(","),
        meta: "nick,mail,link".split(","),
        requiredMeta: "nick".split(","),
        lang: "",
        wordLimit: 0,
        pageSize: "10",
        login: "enable",
        
    });
</script>



    
</body>
</html>
